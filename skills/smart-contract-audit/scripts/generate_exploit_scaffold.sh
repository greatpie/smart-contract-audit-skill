#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lib.sh"

usage() {
  cat <<'EOF'
Usage:
  bash scripts/generate_exploit_scaffold.sh --repo-dir <path> [options]

Options:
  --repo-dir <path>         Target repository path (required)
  --framework <name>        auto|foundry|hardhat (default: auto)
  --force                   Overwrite existing scaffold file
  --help                    Show this message
EOF
}

REPO_DIR=""
FRAMEWORK="auto"
FORCE="0"

while [ "$#" -gt 0 ]; do
  case "$1" in
    --repo-dir)
      REPO_DIR="${2:-}"
      shift 2
      ;;
    --framework)
      FRAMEWORK="${2:-}"
      shift 2
      ;;
    --force)
      FORCE="1"
      shift
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    *)
      die "Unknown argument: $1"
      ;;
  esac
done

[ -n "$REPO_DIR" ] || {
  usage
  die "--repo-dir is required"
}

REPO_DIR="$(abs_path "$REPO_DIR")"
[ -d "$REPO_DIR" ] || die "Repo path does not exist: $REPO_DIR"
mkdir -p "$REPO_DIR/submission"

if [ "$FRAMEWORK" = "auto" ]; then
  FRAMEWORK="$(detect_framework "$REPO_DIR")"
fi

case "$FRAMEWORK" in
  foundry)
    TARGET_FILE="$REPO_DIR/script/Exploit.s.sol"
    mkdir -p "$(dirname "$TARGET_FILE")"
    if [ -f "$TARGET_FILE" ] && [ "$FORCE" != "1" ]; then
      log "Foundry scaffold already exists: $TARGET_FILE (use --force to overwrite)"
      exit 0
    fi
    cat > "$TARGET_FILE" <<'EOF'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";

interface ITarget {
    // TODO: declare vulnerable entrypoints used in exploit.
    // function vulnerableCall(uint256 amount) external;
}

contract ExploitScript is Script {
    address public constant TARGET = address(0x1111111111111111111111111111111111111111);

    function run() external {
        uint256 attackerPk = vm.envUint("ATTACKER_PK");
        address attacker = vm.addr(attackerPk);
        uint256 beforeBal = attacker.balance;

        vm.startBroadcast(attackerPk);

        // TODO:
        // 1) Optional: deploy helper attacker contract.
        // 2) Call vulnerable path(s) with realistic parameters.
        // 3) If needed, execute a multi-tx sequence (approve, borrow, withdraw, liquidate, etc).
        // Example:
        // ITarget(TARGET).vulnerableCall(1 ether);

        vm.stopBroadcast();

        uint256 afterBal = attacker.balance;
        console2.log("attacker", attacker);
        console2.log("balanceBefore", beforeBal);
        console2.log("balanceAfter", afterBal);
    }
}
EOF
    ;;
  hardhat)
    TARGET_FILE="$REPO_DIR/scripts/exploit.js"
    mkdir -p "$(dirname "$TARGET_FILE")"
    if [ -f "$TARGET_FILE" ] && [ "$FORCE" != "1" ]; then
      log "Hardhat scaffold already exists: $TARGET_FILE (use --force to overwrite)"
      exit 0
    fi
    cat > "$TARGET_FILE" <<'EOF'
/* eslint-disable no-console */
const { ethers } = require("hardhat");

async function main() {
  const rpcUrl = process.env.RPC_URL || "http://127.0.0.1:8756";
  const attackerPk = process.env.ATTACKER_PK;
  if (!attackerPk) {
    throw new Error("ATTACKER_PK is required");
  }

  const provider = new ethers.JsonRpcProvider(rpcUrl);
  const attacker = new ethers.Wallet(attackerPk, provider);
  const before = await provider.getBalance(attacker.address);

  console.log("attacker:", attacker.address);
  console.log("balanceBefore:", before.toString());

  // TODO:
  // 1) Create contract instances with ABI/address.
  // 2) Execute exploit tx sequence with awaits.
  // 3) Collect receipts and state deltas for proof.
  //
  // Example:
  // const target = new ethers.Contract(TARGET_ADDR, TARGET_ABI, attacker);
  // const tx = await target.vulnerableCall(...args);
  // const receipt = await tx.wait();
  // console.log("txHash:", receipt.hash);

  const after = await provider.getBalance(attacker.address);
  console.log("balanceAfter:", after.toString());
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
EOF
    ;;
  *)
    die "Unsupported framework '$FRAMEWORK'. Use --framework foundry|hardhat."
    ;;
esac

cat > "$REPO_DIR/submission/exploit-scaffold-notes.md" <<EOF
# Exploit Scaffold Notes

- Framework: \`$FRAMEWORK\`
- Scaffold file: \`$TARGET_FILE\`

## Next Steps

1. Fill the TODO blocks with a realistic exploit path.
2. Record each tx hash and key state changes in \`submission/txs.md\`.
3. Prefer multi-step stateful exploits over single-call toy PoCs when applicable.
4. Re-run exploit script against a fresh local chain to confirm reproducibility.
EOF

log "Generated exploit scaffold: $TARGET_FILE"
